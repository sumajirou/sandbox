# 参考URL
# https://www.swetake.com/qrcode/qr1.html
# (引用ここから)
# 1.2　ＱＲコードで符号化できる文字
# ・数字(0-9)
# 　３文字を10bitで表現します。
# 　理論上最大7089文字を格納できます。
# ・英数字(0-9A-Z $%*+-./:)の４５文字
# 　２文字を11bitで表現します。
# 　理論上最大4296文字を格納できます。
# ・８ビットバイトデータ
# 　理論上最大2953文字を格納できます。
# ・漢字データ
# 　漢字１文字を13bitで表現します。
# 　理論上最大1817文字を格納できます。
# 1.3　ＱＲコードで選択できる誤り訂正レベル
# 　ＱＲコードではデータの一部が読み取れなかったり黒白を誤って 読んでしまった場合でもその誤りを訂正するために冗長コードを 付加しています。
# 　誤り訂正レベルはＬ、Ｍ、Ｑ、Ｈの４段階に選択でき、復元能力はそれぞれ約7,15,25,30%です。
# 1.4　シンボルのバージョン
# 　ＱＲコードモデル２においてはバージョン１～４０まで存在し、 一辺が２１～１７７モジュールとバージョンが１つあがるごとに４モジュール増加します。
# 　ちなみに１モジュールとはマトリックスの１マスのことをさします
#
# バージョン２以降ではさらにひずみ補正のための位置合わせパターンが使用されます。
# またバージョン７以降ではバージョンを明記する型番情報が付加されます。
#
# サンプルとして ABCDE123 というデータをバージョン１誤り訂正レベルＨ(以下1-H型)で 表記することを考えます。
# (引用ここまで)

# 最初はバージョン1の誤り訂正レベルH(30%)の英数字固定で作ってみる．
# この場合データコード数9のエラー訂正コード数17．9*8 = 11*6+6よって英数字10文字格納できる．(?
# いずれオプションで誤り訂正レベルなど指定できるようにする．


import random
import re
import reedsolo
# U+2588	█	Full block
BLOCK = "██"

# 入力データ
input_data = "ABCDE123"
print("input_data:", input_data)

# モード指示子 英数字モードは0010
mode = '0010'
print("mode:", mode)

# 文字数指示子 英数字モードは9bitで文字数を表す
character_count = format(len(input_data), '09b')
print("character_count:", character_count)

# 2進化データ
# 　英数字モードではまず表2の通りに各文字を数字化します。
# 　データを２桁づつ区切って１桁めの文字の上記の表の値を４５倍したものと２桁目の文字の上記の表の値を足します。
# 　算出された値を11bitの２進数で表記します。なお２桁に満たない場合は残った場合は対応する値を6bitで表記します。

# 2文字ずつ分割
bindata = re.split('(..)', input_data)
# 空文字列の削除
bindata = [x for x in bindata if x]  # => ['AB', 'CD', 'E1', '23']
print("2文字ずつ分割bindata:", bindata)

# 2文字ないし1文字を2進数に変換する関数


def convert_char_to_bin(chars):
    table = {
        "0": 0, "1": 1, "2": 2, "3": 3, "4": 4, "5": 5, "6": 6, "7": 7, "8": 8, "9": 9,
        "A": 10, "B": 11, "C": 12, "D": 13, "E": 14, "F": 15, "G": 16, "H": 17, "I": 18, "J": 19,
        "K": 20, "L": 21, "M": 22, "N": 23, "O": 24, "P": 25, "Q": 26, "R": 27, "S": 28, "T": 29,
        "U": 30, "V": 31, "W": 32, "X": 33, "Y": 34, "Z": 35, " ": 36, "$": 37, "%": 38, "*": 39,
        "+": 40, "-": 41, ".": 42, "/": 43, ":": 44,
    }

    if len(chars) == 2:
        num = table[chars[0]] * 45 + table[chars[1]]
        return format(num, '011b')
    else:
        num = table[chars]
        return format(num, '06b')


bindata = ''.join([convert_char_to_bin(chars) for chars in bindata])
print("bindata:", bindata)

# 終端パターン
eom = '0000'
print("eom:", eom)

# コード語変換
data = mode + character_count + bindata + eom
print("とりあえずくっつけたdata:", data)

# 8の倍数になるようパディング
bit_padding_len = (8 - len(data) % 8) % 8
print("bit_padding_len:", bit_padding_len)
data = data + '0' * bit_padding_len
print("8の倍数にパディングdata:", data)

# シンボルのデータコード数に満たない場合は11101100 および 00010001を交互に付加してシンボル容量にあわせる．
data_code_words = 9
word_padding_len = data_code_words - len(data) / 8
while word_padding_len >= 2:
    data = data + '1110110000010001'
    word_padding_len -= 2

if word_padding_len == 1:
    data = data + '11101100'

print("data:", data)

# 8bit毎に区切って数値に変換
data = [int(x, 2) for x in re.split('(........)', data) if x]
print("data:", data)


# リード・ソロモン誤り訂正コードの追加
# RSブロック数は1
# 総コード語数: 26
# データコード語数: 9
# 誤り訂正数8
# (誤り訂正コード語数:17)
# g(x) = x17  + α43x16 + α139x15 + α206x14 + α78x13 + α43x12 + α239x11  + α123x10 + α206x9 + α214x8 　 + α147x7 + α24x6 + α99x5  + α150x4 + α39x3 + α243x2  + α163x + α136

# 32,65,205,69,41,220,46,128,236

# 表４、GF(2^8)αの指数と整数の対応表
# αの指数：整数
# {0:1,1:2,2:4,3:8,4:16,5:32,6:64,7:128,8:29,9:58,10:116,11:232,12:205,13:135,14:19,15:38,16:76,17:152,18:45,19:90,20:180,21:117,22:234,23:201,24:143,25:3,26:6,27:12,28:24,29:48,30:96,31:192,32:157,33:39,34:78,35:156,36:37,37:74,38:148,39:53,40:106,41:212,42:181,43:119,44:238,45:193,46:159,47:35,48:70,49:140,50:5,51:10,52:20,53:40,54:80,55:160,56:93,57:186,58:105,59:210,60:185,61:111,62:222,63:161,64:95,65:190,66:97,67:194,68:153,69:47,70:94,71:188,72:101,73:202,74:137,75:15,76:30,77:60,78:120,79:240,80:253,81:231,82:211,83:187,84:107,85:214,86:177,87:127,88:254,89:225,90:223,91:163,92:91,93:182,94:113,95:226,96:217,97:175,98:67,99:134,100:17,101:34,102:68,103:136,104:13,105:26,106:52,107:104,108:208,109:189,110:103,111:206,112:129,113:31,114:62,115:124,116:248,117:237,118:199,119:147,120:59,121:118,122:236,123:197,124:151,125:51,126:102,127:204,128:133,129:23,130:46,131:92,132:184,133:109,134:218,135:169,136:79,137:158,138:33,139:66,140:132,141:21,142:42,143:84,144:168,145:77,146:154,147:41,148:82,149:164,150:85,151:170,152:73,153:146,154:57,155:114,156:228,157:213,158:183,159:115,160:230,161:209,162:191,163:99,164:198,165:145,166:63,167:126,168:252,169:229,170:215,171:179,172:123,173:246,174:241,175:255,176:227,177:219,178:171,179:75,180:150,181:49,182:98,183:196,184:149,185:55,186:110,187:220,188:165,189:87,190:174,191:65,192:130,193:25,194:50,195:100,196:200,197:141,198:7,199:14,200:28,201:56,202:112,203:224,204:221,205:167,206:83,207:166,208:81,209:162,210:89,211:178,212:121,213:242,214:249,215:239,216:195,217:155,218:43,219:86,220:172,221:69,222:138,223:9,224:18,225:36,226:72,227:144,228:61,229:122,230:244,231:245,232:247,233:243,234:251,235:235,236:203,237:139,238:11,239:22,240:44,241:88,242:176,243:125,244:250,245:233,246:207,247:131,248:27,249:54,250:108,251:216,252:173,253:71,254:142,255:1}
# 整数：αの指数
# {1:0,2:1,3:25,4:2,5:50,6:26,7:198,8:3,9:223,10:51,11:238,12:27,13:104,14:199,15:75,16:4,17:100,18:224,19:14,20:52,21:141,22:239,23:129,24:28,25:193,26:105,27:248,28:200,29:8,30:76,31:113,32:5,33:138,34:101,35:47,36:225,37:36,38:15,39:33,40:53,41:147,42:142,43:218,44:240,45:18,46:130,47:69,48:29,49:181,50:194,51:125,52:106,53:39,54:249,55:185,56:201,57:154,58:9,59:120,60:77,61:228,62:114,63:166,64:6,65:191,66:139,67:98,68:102,69:221,70:48,71:253,72:226,73:152,74:37,75:179,76:16,77:145,78:34,79:136,80:54,81:208,82:148,83:206,84:143,85:150,86:219,87:189,88:241,89:210,90:19,91:92,92:131,93:56,94:70,95:64,96:30,97:66,98:182,99:163,100:195,101:72,102:126,103:110,104:107,105:58,106:40,107:84,108:250,109:133,110:186,111:61,112:202,113:94,114:155,115:159,116:10,117:21,118:121,119:43,120:78,121:212,122:229,123:172,124:115,125:243,126:167,127:87,128:7,129:112,130:192,131:247,132:140,133:128,134:99,135:13,136:103,137:74,138:222,139:237,140:49,141:197,142:254,143:24,144:227,145:165,146:153,147:119,148:38,149:184,150:180,151:124,152:17,153:68,154:146,155:217,156:35,157:32,158:137,159:46,160:55,161:63,162:209,163:91,164:149,165:188,166:207,167:205,168:144,169:135,170:151,171:178,172:220,173:252,174:190,175:97,176:242,177:86,178:211,179:171,180:20,181:42,182:93,183:158,184:132,185:60,186:57,187:83,188:71,189:109,190:65,191:162,192:31,193:45,194:67,195:216,196:183,197:123,198:164,199:118,200:196,201:23,202:73,203:236,204:127,205:12,206:111,207:246,208:108,209:161,210:59,211:82,212:41,213:157,214:85,215:170,216:251,217:96,218:134,219:177,220:187,221:204,222:62,223:90,224:203,225:89,226:95,227:176,228:156,229:169,230:160,231:81,232:11,233:245,234:22,235:235,236:122,237:117,238:44,239:215,240:79,241:174,242:213,243:233,244:230,245:231,246:173,247:232,248:116,249:214,250:244,251:234,252:168,253:80,254:88,255:175}

# data = [32,65,205,69,41,220,46,128,236]
rsc = reedsolo.RSCodec(17)
data = list(rsc.encode(data))
print("data:", data)

# 2進化
data = ''.join([format(x, '08b') for x in data])
print("data:", data)


def convert_str_to_matrix(buf):
    lines = buf.split('\n')[:-1]
    matrix = [list(line) for line in lines]
    return matrix


def convert_matrix_to_str(matrix):
    lines = [''.join(line) for line in matrix]
    buf = '\n'.join(lines)
    return buf

# バージョン1のQRコードのベース
# 0:白
# 1:黒
# 2:形式情報
# 3:データ・誤り訂正コード


qr = """111111102333301111111
100000102333301000001
101110102333301011101
101110102333301011101
101110102333301011101
100000102333301000001
111111101010101111111
000000002333300000000
222222122333322222222
333333033333333333333
333333133333333333333
333333033333333333333
333333133333333333333
000000001333333333333
111111102333333333333
100000102333333333333
101110102333333333333
101110102333333333333
101110102333333333333
100000102333333333333
111111102333333333333
"""

matrix = convert_str_to_matrix(qr)
base_matrix = convert_str_to_matrix(qr)
# print(matrix)

# データコード部に挿入する
# matrixの座標
x, y = 20, 20
direction = -1  # means 'up'
pos = 'right'  # or 'left

# 今見てるとこがデータコード部ならデータを入れてiを1すすめる．
data_len = len(data)
i = 0
while i < data_len:
    if matrix[y][x] == '3':
        # データコード部なら挿入
        matrix[y][x] = data[i]
        i += 1

    if pos == 'right':
        # 右側のときは左側に移動
        pos = 'left'
        x -= 1
        continue

    pos = 'right'
    if direction == -1 and y == 0:
        # 上端の時は左に移動し方向を下に
        x -= 1
        direction = 1
    elif direction == 1 and y == 20:
        # 下端の時は左に移動し方向を上に
        x -= 1
        direction = -1
    else:
        # どちらでもないときは右に移動し上下に移動
        x += 1
        y += direction

    # 縦のタイミングパターンをスキップする
    if x == 6:
        x -= 1

# 出力は文字列で，内部では二次元配列で扱う．
# 文字列は0と1と改行のみ．末尾に改行あり


def print_qrstr(qrstr):
    table = str.maketrans({'0': '██', '1': '  ', '2': '22', '3': '33'})
    print(qrstr.translate(table))


def add_padding(qrstr):
    qrstr = '0000' + qrstr.replace('\n', '0000\n0000') + '0000\n'
    padding_line = ('0' * 29 + '\n') * 4
    qrstr = padding_line + qrstr + padding_line
    qrstr = qrstr[:-1]
    return qrstr


print_qrstr(add_padding(convert_matrix_to_str(matrix)))
# マスクを8種類適用
# マスクの評価
# とりあえずマスクパターン011を選択	(i+j) mod 3 = 0
for y in range(0, 21):
    for x in range(0, 21):
        # コード部のみ対象とする
        if base_matrix[y][x] == '3' and (x+y) % 3 == 0:
            matrix[y][x] = {'0': '1', '1': '0'}[matrix[y][x]]  # 0と1を反転
            # matrix[y][x] = str(1 - int(matrix[y][x]))  # 0と1を反転

mask_pattern = '011'

# 形式情報の追加
error_correction_level = '10'

# 5桁の2進数を受け取り，BCH(15,5)を計算した結果を2進数で返す


def bch15_5(x):
    g = '10100110111'
    f = x + '0' * 10
    while int(f, 2) >= int(g, 2):
        h = g + '0' * (len(f) - len(g))
        f = format(int(f, 2) ^ int(h, 2), 'b')
    return format(int(f, 2), '010b')


error_correction_bit = bch15_5(error_correction_level + mask_pattern)
print('error_correction_bit', error_correction_bit)

format_info = error_correction_level + mask_pattern + error_correction_bit
print('format_info', format_info)

format_info = format(int(format_info, 2) ^ 0b101010000010010, '015b')
print('format_info', format_info)


# 形式情報の挿入
matrix[8][0:6] = format_info[0:6]
matrix[8][7] = format_info[7]
matrix[8][-8:] = format_info[-8:]

matrix = list(map(list, zip(*matrix)))

# 文字列逆転
format_info = format_info[::-1]
matrix[8][0:6] = format_info[0:6]
matrix[8][7:9] = format_info[7:9]
matrix[8][-7:] = format_info[-7:]
format_info = format_info[::-1]

matrix = list(map(list, zip(*matrix)))

# matrixを文字列に戻す
qr = convert_matrix_to_str(matrix)


qr = add_padding(qr)


print_qrstr(qr)

# 001000000100000111001101010001010010100111011100001011101000000011101100001010101001111101001010110111011111010010101001111011111001011010001010010001101110110101010101111000000110000001001010 11011011 00111101
#          0101
#          0010
#          0110
#          0101
#          1011
#          0011

#          1001
#          0111
# 101100 00111000001010
# 011111 00010101110011
# 100010 01110101011000
# 111010 10100101111011
#          100001000010
#          101010000100
#          101111000100
#          101111011010
#          111010011100
#          011100111000
#          001001011101
#          001101000000


# 余白あり
# コマンドラインで出力すると黒背景の場合が多いので0を黒，1を白の様に反転して出力させたほうが良い．QRコードはネガポジ反転すると認識されないことが多い．(ソフトによる？)
# もちろん色反転オプションは付ける．
"""
00000000000000000000000000000
00000000000000000000000000000
00000000000000000000000000000
00000000000000000000000000000
00001111111023333011111110000
00001000001023333010000010000
00001011101023333010111010000
00001011101023333010111010000
00001011101023333010111010000
00001000001023333010000010000
00001111111010101011111110000
00000000000023333000000000000
00002222221223333222222220000
00003333330333333333333330000
00003333331333333333333330000
00003333330333333333333330000
00003333331333333333333330000
00000000000013333333333330000
00001111111023333333333330000
00001000001023333333333330000
00001011101023333333333330000
00001011101023333333333330000
00001011101023333333333330000
00001000001023333333333330000
00001111111023333333333330000
00000000000000000000000000000
00000000000000000000000000000
00000000000000000000000000000
00000000000000000000000000000
"""

# 2と3をランダムに0か1に変換(モック用途)
# qr = ''.join([random.choice('01') if x in '23' else x for x in qr])

# 0と1を正方形になるように変換


# 出力
# print(qr)
